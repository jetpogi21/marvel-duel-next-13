//Generated by WriteToModeltable_tsx
"use client";
//Generated by GeneratePageFile
import React, { useEffect, useState } from "react";
import { getAxiosParams } from "@/utils/utilities";
import { useDeckStore } from "@/hooks/decks/useDeckStore";
import {
  DeckFormikInitialValues,
  DeckSearchParams,
  DeckUpdatePayload,
  GetDecksResponse,
} from "@/interfaces/DeckInterfaces";
import axiosClient from "@/utils/api";
import {
  InfiniteData,
  useInfiniteQuery,
  useMutation,
  useQueryClient,
} from "@tanstack/react-query";
import { DEFAULT_LIMIT } from "@/utils/constants";
import { useURL } from "@/hooks/useURL";
import { Formik } from "formik";
import { DeckArraySchema } from "@/schema/DeckSchema";
import { toast } from "@/hooks/use-toast";
import {
  DEFAULT_FILTERS,
  DEFAULT_FORM_VALUE,
  DEFAULT_SORT_BY,
} from "@/utils/constants/DeckConstants";
import { useDeckDeleteDialog } from "@/hooks/decks/useDeckDeleteDialog";
import DeckFormArray from "@/components/decks/DeckFormArray";

const DeckTable: React.FC = () => {
  const { query } = useURL<DeckSearchParams>();
  const queryClient = useQueryClient();

  ///Local States
  const [mounted, setMounted] = useState(false);

  //SearchParams Variables
  const q = query["q"] || "";
  const is_hero = query["is_hero"] || "";
  const sort = query["sort"] || DEFAULT_SORT_BY;
  const limit = query["limit"] || DEFAULT_LIMIT;

  //Page constants
  const DEFAULT_DECK = DEFAULT_FORM_VALUE;

  //Store Variables
  const {
    recordCount,
    setRecordCount,
    lastPage,
    setLastPage,
    setPage,
    fetchCount,
    setFetchCount,
    resetRowSelection,
    currentData,
    setCurrentData,
    setIsUpdating,
  } = useDeckStore();

  const [setRecordsToDelete, setIsDialogLoading, setMutate] =
    useDeckDeleteDialog((state) => [
      state.setRecordsToDelete,
      state.setIsDialogLoading,
      state.setMutate,
    ]);

  //API Functions
  const getDecks = async ({ pageParam = "" }) => {
    //First argument is the queries from the form, second one is so that the queries can be turned into the desired shape while the defaultFilters will be the searchParams not included from the from
    const axiosParams = getAxiosParams({ q, is_hero }, DEFAULT_FILTERS, {
      cursor: pageParam,
      limit,
      sort,
      fetchCount: fetchCount.toString(),
    }) as Partial<DeckSearchParams>;

    const { data } = await axiosClient.get<GetDecksResponse>(`decks`, {
      params: axiosParams,
    });

    console.log(data);

    return data;
  };

  const updateDecks = async (payload: DeckUpdatePayload) => {
    const { data } = await axiosClient({
      url: "decks",
      method: "post",
      data: payload,
    });

    return data;
  };
  //API Functions end here

  //Tanstacks
  const { refetch } = useInfiniteQuery(["decks"], getDecks, {
    getNextPageParam: (lastPage) => lastPage.cursor ?? undefined,
    onSuccess: (data) => {
      const dataPageLength = data.pages.length;
      const dataLastPageRowCount = data.pages[dataPageLength - 1].count;

      if (dataPageLength > lastPage) {
        setLastPage(dataPageLength);
        setPage(dataPageLength);
        setCurrentData([
          ...data.pages[dataPageLength - 1].rows.map((item) => ({
            ...item,
            touched: false,
          })),
          { ...DEFAULT_DECK },
        ]);
      } else {
        setLastPage(1);
        setPage(1);
        setCurrentData([
          ...data.pages[0].rows.map((item) => ({
            ...item,
            touched: false,
          })),
          { ...DEFAULT_DECK },
        ]);
      }

      if (dataLastPageRowCount) {
        setFetchCount(false);
        setRecordCount(dataLastPageRowCount);
      }
    },
    enabled: mounted,
  });

  const { mutate } = useMutation(updateDecks, {
    onMutate: () => {
      setIsDialogLoading(true);
      setIsUpdating(true);
    },
    onSuccess: (data: { recordsCreated: number; recordsDeleted: number }) => {
      toast({
        description: "Deck list updated successfully",
        variant: "success",
        duration: 2000,
      });

      //Refetch the current page
      resetRowSelection();
      setRecordCount(recordCount + data.recordsCreated - data.recordsDeleted);
      sliceQueryDataAndRefetch(0);
    },
    onError: (error) => {
      const responseText =
        //@ts-ignore
        error?.response?.statusText || "Something went wrong with the app";
      toast({
        description: responseText,
        variant: "destructive",
        duration: 2000,
      });
    },
    onSettled: () => {
      setIsDialogLoading(false);
      setIsUpdating(false);
      setRecordsToDelete([]);
    },
  });

  //Transformations
  const sliceQueryDataAndRefetch = (idx: number) => {
    queryClient.setQueryData(
      ["decks"],
      (data: InfiniteData<GetDecksResponse> | undefined) => {
        return data
          ? {
              pages: data.pages.slice(0, idx + 1),
              pageParams: data.pageParams.slice(0, idx + 1),
            }
          : undefined;
      }
    );
    refetch();
  };

  //Client Actions
  const handleSubmit = async (values: DeckFormikInitialValues) => {
    //The reference is the index of the row
    const DecksToBeSubmitted = values.Decks.filter((item) => item.touched);

    if (DecksToBeSubmitted.length > 0) {
      const payload: DeckUpdatePayload = {
        Decks: DecksToBeSubmitted,
        deletedDecks: [],
      };

      mutate(payload);
    }
  };

  useEffect(() => {
    setMounted(true);
    setMutate(mutate);
  }, []);

  useEffect(() => {
    if (mounted) {
      sliceQueryDataAndRefetch(0);
    }
  }, [q, is_hero, limit, sort]);

  return (
    <Formik
      initialValues={{
        Decks: currentData,
      }}
      enableReinitialize={true}
      onSubmit={handleSubmit}
      validationSchema={DeckArraySchema}
      validateOnChange={false}
    >
      {(formik) => <DeckFormArray formik={formik} />}
    </Formik>
  );
};

export default DeckTable;
