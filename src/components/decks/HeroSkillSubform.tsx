//Generated by WriteToLeftModelSubform_tsx - LeftModelSubform.tsx
"use client";
import { useHeroSkillColumns } from "@/components/hero-skills/HeroSkillColumns";
import { HeroSkillDeleteDialog } from "@/components/hero-skills/HeroSkillDeleteDialog";
import { Button } from "@/components/ui/Button";
import {
  Table,
  TableHeader,
  TableRow,
  TableHead,
  TableBody,
  TableCell,
} from "@/components/ui/Table";
import { useHeroSkillDeleteDialog } from "@/hooks/hero-skills/useHeroSkillDeleteDialog";
import { useHeroSkillStore } from "@/hooks/hero-skills/useHeroSkillStore";
import { DeckFormFormikInitialValues } from "@/interfaces/DeckInterfaces";
import { HeroSkillFormikShape } from "@/interfaces/HeroSkillInterfaces";
import { cn } from "@/lib/utils";
import {
  COLUMNS,
  DEFAULT_FORM_VALUE,
  FIRST_FIELD_IN_FORM,
  PLURALIZED_MODEL_NAME,
} from "@/utils/constants/HeroSkillConstants";
import { sortData } from "@/utils/sort";
import { getSorting } from "@/utils/utilities";
import { removeItemsByIndexes } from "@/utils/utils";
import {
  useReactTable,
  getCoreRowModel,
  flexRender,
  SortingState,
} from "@tanstack/react-table";
import { FormikProps } from "formik";
import { ChevronLast, Plus } from "lucide-react";
import React, { useEffect, useRef, useState } from "react";
import { useDeckStore } from "@/hooks/decks/useDeckStore";

interface HeroSkillSubformProps {
  formik: FormikProps<DeckFormFormikInitialValues>;
}

const HeroSkillSubform: React.FC<HeroSkillSubformProps> = ({ formik }) => {
  //URL States
  //Local states
  const [willFocus, setWillFocus] = useState(false);
  const ref: React.RefObject<HTMLElement> = useRef(null); //to be attached to the last row in form, first control in that row

  const {
    resetRowSelection,
    rowSelection,
    setRowSelection,
    setRowSelectionToAll,
    sort,
    setSort,
    setCurrentData,
  } = useHeroSkillStore((state) => ({
    resetRowSelection: state.resetRowSelection,
    rowSelection: state.rowSelection,
    setRowSelection: state.setRowSelection,
    setRowSelectionToAll: state.setRowSelectionToAll,
    sort: state.sort,
    setSort: state.setSort,
    setCurrentData: state.setCurrentData,
  }));
  const { setRecordsToDelete } = useHeroSkillDeleteDialog();

  //Zustand
  const { setHasUpdate } = useDeckStore((state) => ({
    setHasUpdate: state.setHasUpdate,
  }));

  //Tanstack queries

  //Page Constants
  const DEFAULT_HEROSKILL = DEFAULT_FORM_VALUE;

  //Transformations
  const sorting = getSorting(sort);
  const hasSelected = Object.values(rowSelection).some((val) => val);
  const dataRowCount = formik.values.HeroSkills.filter(
    (item) => item.id
  ).length;
  const pageStatus = `Showing ${dataRowCount} of ${dataRowCount} record(s)`;

  //Utility Functions

  //Client Actions
  const focusOnRef = () => {
    ref && ref.current?.focus();
  };

  const addRow = () => {
    formik.setFieldValue(`HeroSkills`, [
      ...formik.values.HeroSkills.map((item) => ({ ...item })),
      { ...DEFAULT_HEROSKILL, heroId: formik.values.id },
    ]);
    setWillFocus(true);
  };

  const setTouchedRows = (idx: number) => {
    formik.setFieldValue(`HeroSkills[${idx}].touched`, true);
  };

  const deleteRow = (idx: number) => {
    const id = formik.values.HeroSkills[idx].id;

    if (id) {
      setRecordsToDelete([id.toString()]);
    } else {
      formik.setFieldValue(`HeroSkills`, [
        ...formik.values.HeroSkills.slice(0, idx),
        ...formik.values.HeroSkills.slice(idx + 1),
      ]);
      formik.setErrors({});
      resetRowSelection();
    }
  };

  const deleteSelectedRows = () => {
    const indexes = Object.keys(rowSelection).map((item) => parseInt(item));

    //Compute the Ids to be deleted. the index should be the selected indexes. then see if the rows has an actual id value
    const deletedIDs = formik.values.HeroSkills.filter((_, idx) =>
      indexes.includes(idx)
    )
      .filter((item) => !!item.id)
      .map((item) => item.id.toString());

    if (deletedIDs.length > 0) {
      setRecordsToDelete(deletedIDs);
    } else {
      formik.setFieldValue(
        `HeroSkills`,
        removeItemsByIndexes(formik.values.HeroSkills, indexes)
      );
      formik.setErrors({});
      resetRowSelection();
    }
  };

  const toggleRow = (idx: number) => setRowSelection(idx);
  const toggleSelectAllRow = () => {
    if (Object.keys(rowSelection).length === formik.values.HeroSkills.length) {
      resetRowSelection();
    } else {
      setRowSelectionToAll(formik.values.HeroSkills.length);
    }
  };

  const handleSortChange = (sortingState: SortingState) => {
    const sortParams = sortingState
      .map((item) => {
        if (item.desc) {
          return `-${item.id}`;
        } else {
          return `${item.id}`;
        }
      })
      .join(",");

    setSort(sortParams);

    formik.setFieldValue(
      "HeroSkills",
      formik.values.HeroSkills.filter((item) => item.id).sort((a, b) => {
        const desc = sortParams.includes("-");
        const field = desc ? sortParams.substring(1) : sortParams;

        return sortData(a, b, desc, field, COLUMNS);
      })
    );
    resetRowSelection();
  };

  const HeroSkillColumns = useHeroSkillColumns();
  const heroSkillTable = useReactTable<HeroSkillFormikShape>({
    data: formik.values.HeroSkills,
    columns: HeroSkillColumns,
    state: {
      sorting: sorting,
      rowSelection,
    },
    //@ts-ignore
    onRowSelectionChange: (state) => setRowSelection(state()),
    //@ts-ignore
    onSortingChange: (state) => handleSortChange(state()), //since the sort state is getting tracked from the url do handle instead
    getCoreRowModel: getCoreRowModel(),
    enableMultiRowSelection: true,
    initialState: {
      columnVisibility: {
        heroId: false,
      },
    },
    meta: {
      name: PLURALIZED_MODEL_NAME,
      setHasUpdate: () => setHasUpdate(true),
      setTouchedRows,
      addRow,
      deleteRow,
      toggleRow,
      toggleSelectAllRow,
      firstFieldInForm: FIRST_FIELD_IN_FORM,
      lastFieldInForm: "description",
      ref,
      editable: true,
    },
  });

  //useEffects here
  useEffect(() => {
    setCurrentData(formik.values.HeroSkills);
    if (willFocus) {
      focusOnRef();
    }
  }, [formik.values.HeroSkills]);

  return (
    <div className="flex flex-col gap-2">
      <h3 className="text-xl font-bold">Hero Skills</h3>
      <div className="flex items-center gap-4">
        <div className="text-sm">
          {heroSkillTable.getFilteredSelectedRowModel().rows.length} of{" "}
          {heroSkillTable.getFilteredRowModel().rows.length} row(s) selected.
        </div>
        {hasSelected && (
          <Button
            type="button"
            size={"sm"}
            variant={"destructive"}
            onClick={() => {
              deleteSelectedRows();
            }}
          >
            Delete Selected
          </Button>
        )}
        <Button
          className="ml-auto"
          variant={"secondary"}
          type="button"
          size="sm"
          onClick={focusOnRef}
        >
          <ChevronLast className="w-4 h-4 text-green-800" />
          Go to last row
        </Button>
      </div>

      <div className="border rounded-md">
        <Table>
          <TableHeader>
            {heroSkillTable.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  //@ts-ignore
                  const customWidth = header.column.columnDef.meta?.width;
                  return (
                    <TableHead
                      key={header.id}
                      className={cn(
                        {
                          "w-[50px]": ["select", "actions"].includes(header.id),
                        },
                        "p-2"
                      )}
                      style={{
                        width: `${customWidth}px`,
                      }}
                    >
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext()
                          )}
                    </TableHead>
                  );
                })}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {heroSkillTable.getRowModel().rows?.length ? (
              heroSkillTable.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell
                      key={cell.id}
                      className="p-2"
                    >
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={HeroSkillColumns.length}
                  className="h-24 text-center"
                >
                  {"No results."}
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>
      <div className="flex items-center justify-between flex-1 text-sm select-none text-muted-foreground">
        {
          <div className="flex items-center justify-between w-full gap-4">
            <p className="hidden md:block">{pageStatus}</p>
            <div className="flex gap-2">
              <Button
                type="button"
                size="sm"
                variant={"secondary"}
                onClick={addRow}
              >
                <Plus className="w-4 h-4 text-green-800" /> Add Row
              </Button>
            </div>
          </div>
        }
      </div>
      <HeroSkillDeleteDialog formik={formik} />
    </div>
  );
};

export default HeroSkillSubform;
