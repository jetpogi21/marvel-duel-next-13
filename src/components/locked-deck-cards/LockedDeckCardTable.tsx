//Generated by WriteToModeltable_tsx - ModelTable.tsx
"use client";
//Generated by GeneratePageFile
import React, { useEffect, useState } from "react";
import { getAxiosParams } from "@/utils/utilities";
import { useLockedDeckCardStore } from "@/hooks/locked-deck-cards/useLockedDeckCardStore";
import {
  LockedDeckCardFormikInitialValues,
  LockedDeckCardSearchParams,
  LockedDeckCardUpdatePayload,
  GetLockedDeckCardsResponse,
  LockedDeckCardDeletePayload,
} from "@/interfaces/LockedDeckCardInterfaces";
import axiosClient from "@/utils/api";
import {
  InfiniteData,
  useInfiniteQuery,
  useMutation,
  useQueryClient,
} from "@tanstack/react-query";
import { DEFAULT_LIMIT } from "@/utils/constants";
import { useURL } from "@/hooks/useURL";
import { Formik } from "formik";
import { LockedDeckCardArraySchema } from "@/schema/LockedDeckCardSchema";
import { toast } from "@/hooks/use-toast";
import {
  DEFAULT_FILTERS,
  DEFAULT_FORM_VALUE,
  DEFAULT_SORT_BY,
} from "@/utils/constants/LockedDeckCardConstants";
import { useLockedDeckCardDeleteDialog } from "@/hooks/locked-deck-cards/useLockedDeckCardDeleteDialog";
import LockedDeckCardFormArray from "@/components/locked-deck-cards/LockedDeckCardFormArray";

const LockedDeckCardTable: React.FC = () => {
  const { query } = useURL<LockedDeckCardSearchParams>();
  const queryClient = useQueryClient();

  ///Local States
  const [mounted, setMounted] = useState(false);

  //SearchParams Variables
  //Generated by GetAllSearchParamsBySeqModel

  const sort = query["sort"] || DEFAULT_SORT_BY;
  const limit = query["limit"] || DEFAULT_LIMIT;

  //Page constants
  const DEFAULT_LOCKEDDECKCARD = DEFAULT_FORM_VALUE;

  //Store Variables
  const {
    recordCount,
    setRecordCount,
    lastPage,
    setLastPage,
    setPage,
    fetchCount,
    setFetchCount,
    resetRowSelection,
    currentData,
    setCurrentData,
    setIsUpdating,
  } = useLockedDeckCardStore();

  const [setRecordsToDelete, setIsDialogLoading, setMutate] =
    useLockedDeckCardDeleteDialog((state) => [
      state.setRecordsToDelete,
      state.setIsDialogLoading,
      state.setMutate,
    ]);

  //API Functions
  const getLockedDeckCards = async ({ pageParam = "" }) => {
    //First argument is the queries from the form, second one is so that the queries can be turned into the desired shape while the defaultFilters will be the searchParams not included from the from
    const axiosParams = getAxiosParams(
      {
        //Generated by GetAllFilterQueryNameBySeqModel
      },
      DEFAULT_FILTERS,
      {
        cursor: pageParam,
        limit,
        sort,
        fetchCount: fetchCount.toString(),
      }
    ) as Partial<LockedDeckCardSearchParams>;

    const { data } = await axiosClient.get<GetLockedDeckCardsResponse>(
      `locked-deck-cards`,
      {
        params: axiosParams,
      }
    );

    return data;
  };

  const updateLockedDeckCards = async (
    payload: LockedDeckCardUpdatePayload
  ) => {
    const { data } = (await axiosClient({
      url: "locked-deck-cards/multi",
      method: "post",
      data: payload,
    })) as { data: { recordsCreated: number } };

    return data;
  };

  const deleteLockedDeckCards = async (
    payload: LockedDeckCardDeletePayload
  ) => {
    const { data } = (await axiosClient({
      url: "locked-deck-cards",
      method: "delete",
      data: payload,
    })) as { data: { recordsDeleted: number } };

    return data;
  };

  //API Functions end here

  //Tanstacks
  const { refetch } = useInfiniteQuery(
    ["lockedDeckCards"],
    getLockedDeckCards,
    {
      getNextPageParam: (lastPage) => lastPage.cursor ?? undefined,
      onSuccess: (data) => {
        const dataPageLength = data.pages.length;
        const dataLastPageRowCount = data.pages[dataPageLength - 1].count;

        if (dataPageLength > lastPage) {
          setLastPage(dataPageLength);
          setPage(dataPageLength);
          setCurrentData([
            ...data.pages[dataPageLength - 1].rows.map((item, index) => ({
              ...item,
              index,
              touched: false,
            })),
            {
              ...DEFAULT_LOCKEDDECKCARD,
              index: data.pages[dataPageLength - 1].rows.length,
            },
          ]);
        } else {
          setLastPage(1);
          setPage(1);
          setCurrentData([
            ...data.pages[0].rows.map((item, index) => ({
              ...item,
              index,
              touched: false,
            })),
            {
              ...DEFAULT_LOCKEDDECKCARD,
              index: data.pages[dataPageLength - 1].rows.length,
            },
          ]);
        }

        if (dataLastPageRowCount) {
          setFetchCount(false);
          setRecordCount(dataLastPageRowCount);
        }
      },
      enabled: mounted,
      staleTime: Infinity,
    }
  );

  //Generated by GetMutationSnippets
  type MutationData = { recordsCreated?: number; recordsDeleted?: number };
  const useHandleMutation = (
    mutationFunction: (payload: any) => Promise<MutationData>,
    successCallback: (data: MutationData) => string,
    updateRecordCountCallback: (
      recordCount: number,
      data: MutationData
    ) => number
  ) => {
    const { mutate } = useMutation(mutationFunction, {
      onMutate: () => {
        setIsDialogLoading(true);
        setIsUpdating(true);
      },
      onSuccess: (data) => {
        toast({
          description: successCallback(data),
          variant: "success",
          duration: 2000,
        });
        resetRowSelection();
        setRecordCount(updateRecordCountCallback(recordCount, data));
        sliceQueryDataAndRefetch(0);
      },
      onError: (error) => {
        const responseText =
          //@ts-ignore
          error?.response?.statusText || "Something went wrong with the app";
        toast({
          description: responseText,
          variant: "destructive",
          duration: 2000,
        });
      },
      onSettled: () => {
        setIsDialogLoading(false);
        setIsUpdating(false);
        setRecordsToDelete([]);
      },
    });

    return mutate;
  };

  // Usage for deleteLockedDeckCardMutation
  const deleteLockedDeckCardMutation = useHandleMutation(
    deleteLockedDeckCards,
    (data) => {
      return "Locked Deck Card(s) deleted successfully";
    },
    (recordCount, data) => {
      return recordCount - (data.recordsDeleted || 0);
    }
  );

  // Usage for updateLockedDeckCards
  const updateLockedDeckCardsMutation = useHandleMutation(
    updateLockedDeckCards,
    (data) => {
      return "Locked Deck Card list updated successfully";
    },
    (recordCount, data) => {
      return (
        recordCount + (data.recordsCreated || 0) - (data.recordsDeleted || 0)
      );
    }
  );

  //Transformations
  const sliceQueryDataAndRefetch = (idx: number) => {
    queryClient.setQueryData(
      ["lockedDeckCards"],
      (data: InfiniteData<GetLockedDeckCardsResponse> | undefined) => {
        return data
          ? {
              pages: data.pages.slice(0, idx + 1),
              pageParams: data.pageParams.slice(0, idx + 1),
            }
          : undefined;
      }
    );
    refetch();
  };

  //Client Actions
  const handleSubmit = async (values: LockedDeckCardFormikInitialValues) => {
    //The reference is the index of the row
    const LockedDeckCardsToBeSubmitted = values.LockedDeckCards.filter(
      (item) => item.touched
    );

    if (LockedDeckCardsToBeSubmitted.length > 0) {
      const payload: LockedDeckCardUpdatePayload = {
        LockedDeckCards: LockedDeckCardsToBeSubmitted,
      };

      updateLockedDeckCardsMutation(payload);
    }
  };

  useEffect(() => {
    setMounted(true);
    setMutate(deleteLockedDeckCardMutation);
  }, []);

  useEffect(() => {
    if (mounted) {
      sliceQueryDataAndRefetch(0);
    }
  }, [
    limit,
    sort, //Generated by GetAllFilterQueryNameBySeqModel
  ]);

  return (
    <Formik
      initialValues={{
        LockedDeckCards: currentData,
      }}
      enableReinitialize={true}
      onSubmit={handleSubmit}
      validationSchema={LockedDeckCardArraySchema}
      validateOnChange={false}
    >
      {(formik) => <LockedDeckCardFormArray formik={formik} />}
    </Formik>
  );
};

export default LockedDeckCardTable;
